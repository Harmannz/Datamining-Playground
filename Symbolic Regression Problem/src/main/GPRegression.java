package main;
import java.util.List;

import org.jgap.InvalidConfigurationException;
import org.jgap.gp.CommandGene;
import org.jgap.gp.GPFitnessFunction;
import org.jgap.gp.GPProblem;
import org.jgap.gp.IGPProgram;
import org.jgap.gp.function.Add;
import org.jgap.gp.function.Cosine;
import org.jgap.gp.function.Divide;
import org.jgap.gp.function.Exp;
import org.jgap.gp.function.Multiply;
import org.jgap.gp.function.Sine;
import org.jgap.gp.function.Subtract;
import org.jgap.gp.impl.DeltaGPFitnessEvaluator;
import org.jgap.gp.impl.GPConfiguration;
import org.jgap.gp.impl.GPGenotype;
import org.jgap.gp.terminal.Constant;
import org.jgap.gp.terminal.Terminal;
import org.jgap.gp.terminal.Variable;

import DAO.DataSet;
import DAO.Instance;
import Util.GPClassifier;

public class GPRegression
    extends GPProblem {
  /** String containing the CVS revision. Read out via reflection!*/
  private final static String CVS_REVISION = "$Revision: 1.25 $";

  private static final int MAXIMUM_EVOLUTIONS = 800;
  private static final int TERMINATION_CRITERIA = 0;
  public static Variable vx;


  protected static List<Instance> instances;
  
  public GPRegression(GPConfiguration a_conf)
      throws InvalidConfigurationException {
    super(a_conf);
  }

  /**
   * This method is used for setting up the commands and terminals that can be
   * used to solve the problem.
   * In this example an ADF (an automatically defined function) is used for
   * demonstration purpuses. Using an ADF is optional. If you want to use one,
   * care about the places marked with "ADF-relevant:" below. If you do not want
   * to use an ADF, please remove the below places (and reduce the outer size of
   * the arrays "types", "argTypes" and "nodeSets" to one).
   * Please notice, that the variables types, argTypes and nodeSets correspond
   * to each other: they have the same number of elements and the element at
   * the i'th index of each variable corresponds to the i'th index of the other
   * variables!
   *
   * @return GPGenotype
   * @throws InvalidConfigurationException
   */
  public GPGenotype create()
      throws InvalidConfigurationException {
    GPConfiguration conf = getGPConfiguration();
    // At first, we define the return type of the GP program.
    // ------------------------------------------------------
    Class[] types = {
        // Return type of result-producing chromosome
        CommandGene.FloatClass};
    // Then, we define the arguments of the GP parts. Normally, only for ADF's
    // there is a specification here, otherwise it is empty as in first case.
    // -----------------------------------------------------------------------
    Class[][] argTypes = {
        // Arguments of result-producing chromosome: none
        {}
    };
    // Next, we define the set of available GP commands and terminals to use.
    // Please see package org.jgap.gp.function and org.jgap.gp.terminal
    // You can easily add commands and terminals of your own.
    // ----------------------------------------------------------------------
    CommandGene[][] nodeSets = { {
        // We use a variable that can be set in the fitness function.
        // ----------------------------------------------------------
        vx = Variable.create(conf, "X", CommandGene.FloatClass),
		new Multiply(conf, CommandGene.FloatClass), 
		new Add(conf, CommandGene.FloatClass),
		new Divide(conf, CommandGene.FloatClass), 
		new Subtract(conf, CommandGene.FloatClass),
		new Sine(conf, CommandGene.FloatClass),
		new Cosine(conf, CommandGene.FloatClass),
		new Exp(conf, CommandGene.FloatClass)
//		new Constant(conf, CommandGene.FloatClass, 1.0f), 
//        new Terminal(conf, CommandGene.FloatClass, 2.0d, 10.0d, true)
    	}
    };
    instances = new DataSet("training.csv").loadDataSet();
    
    // ------------------------------------------------------------------------
    return GPGenotype.randomInitialGenotype(conf, types, argTypes, nodeSets,
        127, true);
  }

  /**
   * Starts the GP Regression.
   *
   * @param args ignored
   * @throws Exception
   *
   */
  public static void main(String[] args)
      throws Exception {
    System.out.println("Formula to discover: X^4 - 2X^3 + X^2 - 1");
    // Setup the algorithm's parameters.
    // ---------------------------------
    GPConfiguration config = new GPConfiguration();
    // We use a delta fitness evaluator because we compute a defect rate, not
    // a point score!
    // ----------------------------------------------------------------------
    config.setGPFitnessEvaluator(new DeltaGPFitnessEvaluator());
    config.setMaxInitDepth(8); //max depth of initial depth
    config.setPopulationSize(800);
    config.setMaxCrossoverDepth(10); //max depth of tree generated by cross over
    config.setReproductionProb(0.05f);
    config.setCrossoverProb(0.9f);
    config.setMutationProb(0.05f);
    config.setFitnessFunction(new GPRegression.FormulaFitnessFunction());
    config.setStrictProgramCreation(true);
    GPProblem problem = new GPRegression(config);
    // Create the genotype of the problem, i.e., define the GP commands and
    // terminals that can be used, and constrain the structure of the GP
    // program.
    // --------------------------------------------------------------------
    GPGenotype gp = problem.create();
    gp.setVerboseOutput(true);
    // Start the computation with maximum 800 evolutions.
    // if a satisfying result is found (fitness value almost 0), JGAP stops
    // earlier automatically.
    // --------------------------------------------------------------------
    evolveGeneticPopulation(gp);
    
    // Print the best solution so far to the console.
    // ----------------------------------------------
    gp.outputSolution(gp.getAllTimeBest());
    // Create a graphical tree of the best solution's program and write it to
    // a PNG file.
    // ----------------------------------------------------------------------
    problem.showTree(gp.getAllTimeBest(), "mathproblem_best.png");
    
	gp.outputSolution(gp.getAllTimeBest());
	classifyTestData(gp);
  }

  private static void classifyTestData( GPGenotype gp) {
      
	  GPRegression.instances = new DataSet("test.csv").loadDataSet();

      double result = new GPRegression.FormulaFitnessFunction().computeRawFitness(gp.getAllTimeBest());
//      result = (double) Math.round(result * 100) / 100;

      System.out.println("MSE on test set: " + result);
  }
  
  private static void evolveGeneticPopulation(GPGenotype geneticProgram) {
      for (int generations = 0; generations < MAXIMUM_EVOLUTIONS; generations += 1) {
          geneticProgram.evolve(1);
          if (geneticProgram.getAllTimeBest() != null && geneticProgram.getAllTimeBest().getFitnessValue() <= TERMINATION_CRITERIA) {
              System.out.println("============================\n"
					+ "TERMINATION CRITERIA REACHED"
					+ "IN " + generations + " generations"
					+ "\n============================\n"
  				+ "Solution with classification accuracy >= " + TERMINATION_CRITERIA + " was found.\n"
					+ "");
          break;
          }
      }
  }
  public static class FormulaFitnessFunction
      extends GPFitnessFunction {
    protected double evaluate(final IGPProgram a_subject) {
      return computeRawFitness(a_subject);
    }

    public double computeRawFitness(final IGPProgram ind) {
      double error = 0.0f;
      Object[] noargs = new Object[0];
      // Evaluate function for input numbers 0 to 20.
      // --------------------------------------------
      for(Instance instance : instances) {
        // Provide the variable X with the input number.
        // See method create(), declaration of "nodeSets" for where X is
        // defined.
        // -------------------------------------------------------------
        vx.set(instance.getxValue());
        try {
          // Execute the GP program representing the function to be evolved.
          // As in method create(), the return type is declared as float (see
          // declaration of array "types").
          // ----------------------------------------------------------------
          double result = ind.execute_float(0, noargs);
          // -------------------------------------------------------------------
          error += Math.pow(Math.abs(result - instance.getyValue()), 2);
          // If the error is too high, stop evlauation and return worst error
          // possible.
          // ----------------------------------------------------------------
          if (Double.isInfinite(error)) {
            return Double.MAX_VALUE;
          }
        } catch (ArithmeticException ex) {
          // This should not happen, some illegal operation was executed.
          // ------------------------------------------------------------
          System.out.println("x = " + instance.getxValue());
          System.out.println(ind);
          throw ex;
        }
      }
      //now normalise the error by dividing it by total 
      error = error / instances.size();
      // In case the error is small enough, consider it perfect.
      // -------------------------------------------------------
      if (error < 0.01) {
        error = 0.0d;
      }
      return error;
    }
  }
}